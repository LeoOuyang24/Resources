This document keeps track of all changes as well as considered changes made to the resources as well as why they were made. Consider this a "learning from the past" kind of document. 

11/30/2022: 
	Added floatEquals to vanilla.h. Basically a way to check if two floats are equal given a certain precision range. FLOAT_COMPARE is a macro that lets us do things like >= between floats without having to do (a > b) || (floatEquals(a,b). Basically it's shorthand. This can be used to make other parts of the resources library more accurate

11/21/2022:
	SUccessfully implemented separating axis theorem for collision between rotated rectangles. This nearly halved the run time per frame in SpatialHashGrid. The way it works is a little bit different from how SAT is explained online, but the general mathematical principles are the same. Instead of projecting the vertices onto each rectangles' axis, however, we instead transform one rectangle around the other, essentially converting the other rectangle back into a non-rotate rectangle. From there we compare their bounding boxes, to see if they interesect, then repeat with the other rectangle as the transformed one. If both bounding boxes intersect, we have a collision.

8/28/2022:
	ForcesComponent now adds forces once every millisecond, which is calculated using DeltaTime::deltaTime.
	MoveComponent now has a new parent class called BasicMoveComponent, which simply implements a moveVector that is added to the rect position. Sometimes, MoveComponent's target based movements are just not a good fit, so BasicMoveComponent will provide a much simpler interface.

08/25/2022:
	Added minor RenderCamera setters that allow the user to more easily modify the camera's position.

8/19/2022:
	Added a startingFrame variable to SpriteComponent that tracks when an animation started running; obviously useless if the sprite is an actual sprite and not a spritesheet, although I think that'll be rare. This variable works with the new BaseAnimation::getFrameIndex() function which returns the current frame that should be run given a startingFrame and the fps. It's a very simple function but is very useful for ensuring that each frame of an animation is run sequentially rather than leaving it to SDL_GetTicks().

8/12/2022:
	- Sequencer now instead of calling a Callable once a frame for a set duration, will now guarantee that a Callable will run its requested number of iterations (unless Callable's function returns true of course). This eliminates the need for a "timePassed" variable, and is instead replaced with "numOfReps" which represents the number of times we've called the Callable. This helps ensure that if the number of repetitions is higher than the time frame, that they will all be run and at a higher rate than before. Previously, a Callable would never be called more times than the time frame; at best it would called the same number of times, since a Callable could at most be called once per frame. Now, a Callable can be called an unlimited number of times a frame.


8/7/2022: 
	- Added TaskID, which allows SpatialGrid to update entities without updating them more than once
	- Fixed bug where SpatialGrid::Node wasn't hashing entities correctly. SpatialGrid::normalizeCoord is now available globally, allowing Node to use the function
	- RenderComponent no longer takes in a camera; it's easier just to use RenderCamera::currentCamera. If RenderComponents need different cameras in the future, just change the current camera. 
	- SpriteComponent no longer has a modified variable. Instead, sParam is set to defaultRender() immediately after rendering; if it's modified, it is rendered as modified. This is a much simpler solution that allows SpriteComponent to be easy to use while also allowing modifications that only last one frame.
	- RenderProgram now renders sprites in ascending z order again.

12/5/2019:
	RawQuadTree was changed from a quadtree of raw pointers to weak pointers before being changed back to raw pointers. The reason for changing to weak pointers was to prevent dangling pointers in the case of a master list deleting an object. However, there's no reason to use weak ptr because removal of the object from the master list also removes the pointer from the quadtree. The benefit of a weak_ptr is that it keeps track of whether or not 
the object still exists but in this case, it wouldn't matter since the pointer would be deleted anyway. The remove function from the quadtree already removes the pointers in the tree, so it makes no sense to have weak_ptr. 
	QuadTree's getNearest methods were changed to modify a vector of shared_ptr. This allows for std::shared_ptr or weak_ptr copying and allows other objects to share QuadTree's ownership.