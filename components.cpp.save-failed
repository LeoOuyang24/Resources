#include <iostream>

#include "vanilla.h"
#include "SDLHelper.h"
#include "render.h"

#include "components.h"



Component::Component(Entity& entity) : entity(&entity), ComponentContainer<Component>(nullptr)
{

}

void Component::update()
{

}
void Component::collide(Entity& other)
{

}
void Component::onDeath()
{

}

Entity& Component::getEntity()
{
    return *entity;
}

Component::~Component()
{
    //std::cout << this << std::endl;
}

RectComponent::RectComponent(const glm::vec4& rect, Entity& entity) : Component(entity), ComponentContainer<RectComponent>(&entity), RectPositional(rect)
{

}

void RectComponent::setRect(const glm::vec4& rect)
{
    this->rect = rect;
}

void RectComponent::setPos(const glm::vec2& pos)
{
    this->rect.x = pos.x;
    this->rect.y = pos.y;
}

void RectComponent::setCenter(const glm::vec2& center)
{
    this->rect.x = center.x - rect.z/2;
    this->rect.y = center.y - rect.a/2;
}

glm::vec2 RectComponent::getPos()
{
    return {rect.x,rect.y};
}

glm::vec2 RectComponent::getCenter()
{
    return {rect.x + rect.z/2, rect.y + rect.a/2};
}

RectComponent::~RectComponent()
{

}

MoveComponent::MoveComponent(double speed, const glm::vec4& rect, Entity& entity) : RectComponent(rect, entity), ComponentContainer<MoveComponent>(&entity),
                                                                                    baseSpeed(speed),speed(speed)
{
    target = {rect.x + rect.z/2, rect.y + rect.a/2};
}

bool MoveComponent::collides(const glm::vec4& target)
{
    return vecIntersect(target,rect,tilt,0);
}

void MoveComponent::teleport(const glm::vec2& point)
{
    rect.x = point.x - rect.z/2; //rect.x += point.x - (rect.x + rect.z/2) -> rect.x = point.x - rect.z/2
    rect.y = point.y - rect.a/2;
    setTarget(point);
}

glm::vec2 MoveComponent::getNextPoint()
{
    glm::vec2 center = {rect.x + rect.z/2, rect.y + rect.a/2};
    angle = atan2((target.y - (center.y)),(target.x - (center.x)));
    return getCenter() + glm::vec2(absMin(cos(angle)*speed*DeltaTime::deltaTime,target.x - center.x),absMin(sin(angle)*speed*DeltaTime::deltaTime, target.y - center.y));
}

void MoveComponent::update()
{
    glm::vec2 center = getCenter();
    if (!atTarget())
    {
        glm::vec2 nextPoint = getNextPoint();
        rect.x += nextPoint.x - center.x;
        rect.y += nextPoint.y - center.y;
    }
    velocity = pointDistance({rect.x + rect.z/2, rect.y + rect.a/2}, center); //distance between new center vs old center
    speed = baseSpeed;
}

bool MoveComponent::atPoint(const glm::vec2& point)
{
    return pointDistance(getCenter(),point) <= distThreshold;
}

bool MoveComponent::atTarget()
{
    return atPoint(target);
}


const glm::vec2& MoveComponent::getTarget()
{
    return target;
}

void MoveComponent::setTarget(const glm::vec2& point)
{
    target = point;
}

float MoveComponent::getAngle()
{
    return angle;
}

float MoveComponent::getTilt()
{
    return tilt;
}

void MoveComponent::setTilt(float newTilt)
{
    tilt = newTilt;
}

double MoveComponent::getVelocity()
{
    return velocity;
}

double MoveComponent::getBaseSpeed()
{
    return baseSpeed;
}

double MoveComponent::getCurSpeed()
{
    return speed;
}

void MoveComponent::setSpeed(double newspeed)
{
    speed = newspeed;
}

MoveComponent::~MoveComponent()
{

}

void ForcesComponent::applyForce(ForceVector force)
{
   float y = sin(force.angle)*force.magnitude;
    float x = cos(force.angle)*force.magnitude;

    finalForce.x += x;
    finalForce.y += y;
}

void ForcesComponent::applyAllForces()
{
        auto end = forces.end();
       for (auto start = forces.begin(); start != end;)
       {
           applyForce(*start);
           start->frames -= 1;
           if (start->frames == 0)
           {
               start = forces.erase(start);
           }
           else
           {
               start->magnitude *= 1 + start->increment/100.0;
               ++start;
           }
       }
}

ForcesComponent::ForcesComponent(Entity& entity) : Component(entity), ComponentContainer<ForcesComponent>(&entity), move(entity.getComponent<MoveComponent>())
{
    if (!move)
    {
        throw std::logic_error("Entity has ForcesComponent but no MoveComponent!");
    }
}

bool ForcesComponent::getBeingPushed()
{
    return forces.size() > 0 || finalForce.x != 0 || finalForce.y != 0;
}

void ForcesComponent::addForce(ForceVector force)
{
    if (force.frames > 1)
    {
        force.frames -= 1;
        forces.push_back(force);
    }
    else
    {
        applyForce(force); //we can save some time by automatically applying one-time forces
    }
}

void ForcesComponent::update()
{

    if ((finalForce.x != 0 || finalForce.y != 0 || forces.size() > 0) && move)
    {
        applyAllForces();
        move->setPos(move->getPos() + finalForce);
        finalForce = glm::vec2(0);
       // forces.clear();
    }

}

RenderComponent::RenderComponent(Entity& entity, RenderCamera* camera) : Component(entity), ComponentContainer<RenderComponent>(&entity), camera(camera)
{

}

void RenderComponent::render(const SpriteParameter& param) //every rendercomponent can take in a SpriteParameter and render it accordingly
{

}

RenderComponent::~RenderComponent()
{

}

SpriteComponent::SpriteComponent(SpriteWrapper& sprite_, bool animated_, Entity& entity, RenderCamera* camera) : RenderComponent(entity, camera),
                                                                                                                ComponentContainer<SpriteComponent>(entity),
                                                                                                                        sprite(&sprite_),
                                                                                                                        animated(animated_)
{

}

void SpriteComponent::render(const SpriteParameter& param)
{
    if (sprite)
    {
        sprite->request(param);
    }
}

void SpriteComponent::setParam(const SpriteParameter& param, const AnimationParameter& animeParam)
{
    this->sParam = param;
    this->aParam = animeParam;
}

void SpriteComponent::update()
{
    if (sprite)
    {
        if (sParam == SpriteParameter()) //if sParam was not modified at all, attempt to render at the entity's position, if possible
        {
            RectComponent* rect = entity->getComponent<RectComponent>();
            if (rect)
            {
                if (camera)
                {
                    sParam.rect = camera->toScreen(rect->getRect());
                }
                else
                {
                    sParam.rect = rect->getRect();
                }
            }
        }
        if (animated)
        {
            static_cast<AnimationWrapper*>(sprite)->request(sParam,aParam);
        }
        else
        {
            sprite->request(sParam,aParam);
        }
        setParam(SpriteParameter(),AnimationParameter()); //reset params
    }
}

Entity::Entity()
{

}


void Entity::addComponent(Component& comp)
{
    components.emplace_back(&comp);
}

void Entity::update()
{
    for (int i = components.size() - 1; i >= 0; --i)
    {
        components[i]->update();
    }
}

void Entity::collide(Entity& entity)
{
    for (int i= components.size() - 1; i >= 0; --i)
    {
        components[i]->collide(entity);
    }
}

void Entity::onDeath()
{
    for (int i = components.size() - 1; i >= 0; --i)
    {
        components[i]->onDeath();
    }
}

Entity::~Entity()
{
    components.clear();
}

Entity* EntityAssembler::assemble()
{
    return nullptr;
}
